ACID，指数据库事务正确执行的四个基本要素的缩写.包含:原子性(Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。一个支持交易（Transaction）的数据库系统，必需要具有这四种特性，否则在交易过程（Transaction processing）当中无法保证数据的正确性,交易过程极可能达不到交易方的要求.  
1、原子性(Atomicity) 

事务的原子性是指事务中包含的所有操作要么都做，要么都不做，保证数据库是一致的。 

例如：A帐户向B帐户划账1000，则先将A减少1000，再将B增加1000，这两个动作要么都提交，要么都回退，不可能发生一个有效、一个无效的情况。  
	update  账户表  set  账户表.账户钱数 = 原钱+1000 where 账户表.用户名 = ‘B’
	update  账户表  set  账户表.账户钱数 = 原钱-1000 where 账户表.用户名 = ‘A’
	commit；
2、一致性(Consistency) 

一致性是指数据库在事务操作前和事务处理后，其中的数据必须都满足业务规则约束。 

例如：A、B帐户的总金额在转账前和转帐后必须一致，其中的不一致必须是短暂的，在事务提交前才会出现的。 

再如：约定B帐户不能多于1000元，则A转出1000成功，B转入1000失败，最终由原子性得到――整个事务回滚 


3、隔离性(Isolation) 

隔离性是数据库允许多个并发事务同时对齐数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。 

例如：在A、B之间转帐时，C同时向A转帐，若同时进行则A、B之间的一致性不能得到满足。所以在A、B事务执行过程中，其他事务不能访问(修改)当前相关的数值。 


4、持久性(Durability) 

持久性表示为：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 

在提交之前如果系统故障，则所有信息全部丢失。提交之后数据存放在磁盘中，是永久性的。
------------------------------------------------------------------------------------
事务隔离级别： 
	1： 读取未提交  带来脏读现象       解决方案就是 读取已提交（使wr阻塞）
	2： 读取已提交  带来不可重复读     解决方案就是 可重复读(rw阻塞)
	3   可重复读    带来幻读           解决方案就是 全阻塞
	4:  序列化   效率极低  不用
	hibernate  1248代表不同隔离级别
------------------------------------------------------------------------------------
事务隔离级别
事务基本概念
ACID即是atomicity（原子性），consistency（一致性），isolation（隔离性）和durability（执久性）的首字母的缩写 
原子性表示一个事务内的所有操作是一个整体，要 么全部成功，要么全失败； 
一致性表示一个事务内有一个操作失败时，所有的更改过的数据都必须回滚到修改前的状态； 
隔离性：事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看中间状态的数据。 
持久性事务完成之后，它对于系统的影响是永久性的。 
事务隔离级别从低到高： 
读取未提交（Read Uncommitted)
读取已提交(Read Committed)
可重复读（Repeatable Read)
序列化（serializable)

读取未提交（Read Uncommitted)
这是最低的事务隔离级别，读事务不会阻塞读事务和写事务，写事务也不会阻塞读事务，但是会阻塞写事务。 
写事务不阻塞读事务，可以读取未提交的数据，容易造成脏读 
脏读现象： 
脏读解决方案： 
如果在第一个事务提交前，任何其他事务不可读取其修改过的值，则可  以避免该问题。 
读取已提交(Read Committed)
写事务就会阻塞读事务和写事务，但是读事务不会阻塞读事务和写事务。读事务不阻塞写事务，但是有可能造成不可重复（在同一个事务中，再次读取数据时【就是你的select操作】，所读取的数据，和第1次读取的数据，不一样了。查询的结果将是不确定的）。 
不可重复读解决方案： 
锁住已经查询出来的记录！不让其他事物进行写操作 
可重复读（Repeatable Read)
读事务会阻塞写事务，但是读事务不会阻塞读事务，写事务会阻塞写事务和读事务。 
读事务不阻塞读事务(针对的是记录而不是表)，可能会造成幻读问题 
幻读解决方案： 
解决办法是锁表，不让产生幻读的记录插入或删除。 
不过，一般不要考虑幻读问题。 
序列化（serializable)
此种隔离级别是最严格的隔离级别，如果设置成这个级别，那么就不会出现以上所有的问题（脏读，不可重复读，幻影读）。 
性能极低，一般不用！ 

我们一般采用读取已提交或者更低的事务隔离级别，配合各种并发访问控制策略来达到并发事务控制的目的。 
如何使用： 
<!-- 制定事务隔离级别 ：1,2,4,8。二进制中：0001, 0010,0100,1000。这样直接采用位运算即可。权限控制中经常采用二进制位运算-->
<property name="hibernate.connection.isolation">2</property> 


乐观锁和悲观锁
乐观锁Optimistic Locking
顾名思义就是保持一种乐观的态度，我们认为系统中的事务并发更新不会很频繁，即使冲突了也没事，大不了重新再来一次。 
它的基本思想就是每次提交一个事务更新时，我们想看看要修改的东西从上次读取以后有没有被其它事务修改过，如果修改过，那么更新就会失败。 
常用实现方法： 
在我们的实体中增加一个版本控制字段，每次事务更新后就将版本(Version)字段：版本字段的值加1.
在实体类中增加@Version, private  int  version；getset 即可。 
悲观锁Pessimistic Locking
基本思想就是每次一个事务读取某一条记录后，就会把这条记录锁住，这样其它的事务要想更新，必须等以前的事务提交或者回滚解除锁。 
悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据） 

乐观锁和悲观锁的比较：
乐观锁：
优势：并发性好，性能较高。
缺点：用户体验不好，录入了半天，提交时被告知已经修改！
  
悲观锁：
优势：会锁住记录，一个用户修改完成前，其他用户不能操作该记录。
缺点：并发性不好，性能不高。
对于悲观锁是针对并发的可能性比较大，而一般在我们的应用中用乐观锁足以。